import {
	BindableObject,
	Button,
	ButtonStyles,
	Component,
	GenericScene,
	Header,
	HStack,
	Icon,
	Identifiable,
	IdentifiableObjectMap,
	Input,
	Label,
	List,
	ListStyles,
	NavigationLink,
	Popover,
	SceneTypes,
	ScrollArea,
	SelectingListItem,
	Separator,
	Sortable,
	Spacer,
	Stage,
	State,
	Text,
	TextInputCfg,
	UUID,
	VisualGroup,
	VStack,
} from '@frugal-ui/base';
import {
	mkdir,
	readdir,
	rename,
	rm,
	writeFile,
} from 'basic-fs-express-frontend';

export enum Types {
	File,
	Directory,
}

export default function FilePicker(
	rootName: string,
	currentPath: BindableObject<string>,
	allowedTypes: Types[],
) {
	return Stage(DirectoryScene, {
		name: rootName,
		isFirst: true,
		path: currentPath.value,
		currentPath,
		allowedTypes,
	});
}

// Utility
async function getDirectoryListing(path: string) {
	const listingText = await readdir(path);
	const listing: DirectoryListing = JSON.parse(listingText);
	return listing;
}

// Directory
interface DirectoryItem {
	name: string;
	isDirectory: boolean;
}

class IdentifiableDirectoryItem implements Identifiable, Sortable {
	uuid = new UUID();
	index = new State(0);

	name: string;
	isDirectory: boolean;

	constructor(item: DirectoryItem, index: number) {
		this.name = item.name;
		this.isDirectory = item.isDirectory;
		this.index.value = index;
	}
}

type DirectoryListing = DirectoryItem[];

interface DirectorySceneCfg {
	name: string;
	isFirst: boolean;
	path: string;
	currentPath: BindableObject<string>;
	allowedTypes: Types[];
}

class DirectoryScene extends GenericScene<DirectorySceneCfg> {
	draw(data: DirectorySceneCfg) {
		this.type = SceneTypes.Column;
		this.accessibilityLabel = `directory ${data.name}`;

		const listUpdater = new State(null);

		function updateList() {
			listUpdater.triggerAll();
		}

		return VStack(
			Header(
				{
					text: data.name.substring(0, 8),
				},
				Button({
					accessibilityLabel: 'refresh directory list',
					iconName: 'refresh',
					action: updateList,
				}),
				creationPopover(
					'File',
					'note_add',
					updateList,
					async (newName) =>
						await writeFile(`${data.path}/${newName}`, ''),
				),
				creationPopover(
					'Directory',
					'create_new_folder',
					updateList,
					async (newName) => await mkdir(`${data.path}/${newName}`),
				),
			),

			DirectoryItemList(
				data.path,
				this,
				listUpdater,
				data.currentPath,
				data.allowedTypes,
			),

			Spacer(),
		);
	}
}

function creationPopover(
	typeName: string,
	iconName: string,
	updateList: () => void,
	createFn: (newName: string) => Promise<void>,
) {
	const isOpen = new State(false);
	const newName = new State('');

	async function create() {
		try {
			await createFn(newName.value);
		} catch {
			alert(`Failed to create ${typeName} "${name}"`);
		}

		isOpen.value = false;
		updateList();
	}

	return Popover({
		isOpen: isOpen,
		accessibilityLabel: `create ${typeName}`,
		toggle: Button({
			iconName: iconName,
			accessibilityLabel: `create ${typeName}`,
			action: () => (isOpen.value = !isOpen.value),
		}),
		content: VStack(
			Label('Name', Input(new TextInputCfg(newName, 'Untitled'))),
			Button({
				style: ButtonStyles.Primary,
				accessibilityLabel: `create ${typeName}`,
				text: `Create ${typeName}`,
				action: create,
			}),
		)
			.cssHeight('auto')
			.cssWidth('18rem')
			.useDefaultPadding()
			.useDefaultSpacing(),
	});
}

function DirectoryItemList(
	path: string,
	parentScene: GenericScene<any>,
	listUpdater: BindableObject<any>,
	currentPath: BindableObject<string>,
	allowedTypes: Types[],
) {
	const itemMap = new IdentifiableObjectMap<IdentifiableDirectoryItem>();
	const visibleItems = new State(
		new IdentifiableObjectMap<IdentifiableDirectoryItem>(),
	);
	const searchString = new State('');

	function update() {
		//update
		visibleItems.value.forEach((item) => {
			const matchInItemMap = itemMap.get(item.uuid);
			if (matchInItemMap == undefined) visibleItems.value.remove(item);
		});

		//search
		itemMap.forEach((item) => {
			const shouldBeVisible =
				item.name
					.toLowerCase()
					.indexOf(searchString.value.toLowerCase()) != -1;

			if (shouldBeVisible) {
				visibleItems.value.set(item);
			} else {
				visibleItems.value.remove(item);
			}
		});

		visibleItems.triggerAll();
	}

	async function refresh() {
		const listing = await getDirectoryListing(path);

		//add new items
		for (let i = 0; i < listing.length; i++) {
			const item = listing[i];
			const matchInItemMap = itemMap
				.values()
				.find((mapItem) => mapItem.name == item.name);
			if (matchInItemMap != undefined) continue;

			const identifiableItem = new IdentifiableDirectoryItem(item, i);
			itemMap.set(identifiableItem);
		}

		//remove items
		itemMap.forEach((item) => {
			const matchInListing = listing.find(
				(listingItem) => listingItem.name == item.name,
			);
			if (matchInListing != undefined) return;

			itemMap.remove(item);
		});

		update();
	}

	listUpdater.addBinding({
		uuid: new UUID(),
		action: refresh,
	});
	refresh();

	searchString.addBinding({
		uuid: new UUID(),
		action: update,
	});
	update();

	return ScrollArea(
		VisualGroup(
			HStack(
				Icon('search')
					.cssPadding('var(--padding-md)')
					.cssPaddingRight('0rem'),
				Input(new TextInputCfg(searchString, 'Search items...')),
			),

			List(
				{
					style: ListStyles.Normal,
					listData: visibleItems,
				},
				(item) =>
					DirectoryItemView({
						parent: path,
						item,
						parentScene,
						listUpdater,
						currentPath,
						allowedTypes,
					}),
			),
		),
	).useDefaultPadding();
}

interface DirectoryItemViewCfg {
	item: IdentifiableDirectoryItem;
	parent: string;
	parentScene: GenericScene<any>;
	listUpdater: BindableObject<any>;
	currentPath: BindableObject<string>;
	allowedTypes: Types[];
}

function DirectoryItemView(configuration: DirectoryItemViewCfg) {
	const { item, currentPath, parentScene, parent } = configuration;
	const path = `${parent}/${item.name}`;

	let component: Component<any>;

	if (item.isDirectory == true) {
		component = NavigationLink<DirectorySceneCfg>(
			{
				accessibilityLabel: item.name,
				parentScene,
				destination: DirectoryScene,
				data: {
					isFirst: false,
					path,
					name: item.name,
					currentPath,
					allowedTypes: configuration.allowedTypes,
				},
			},
			...ItemText({
				parent,
				path,
				name: item.name,
				listUpdater: configuration.listUpdater,
				isDirectory: item.isDirectory,
			}),
		)
			.cssPaddingLeft('0rem')
			.cssPaddingTop('0rem')
			.cssPaddingBottom('0rem');
	} else {
		const uuid = new UUID();
		component = SelectingListItem(
			{
				ownValue: uuid,
				selection: configuration.parentScene.linkSelection,
				isExclusive: true,
			},
			...ItemText({
				parent,
				name: item.name,
				path,
				listUpdater: configuration.listUpdater,
				isDirectory: item.isDirectory,
			}),
		)
			.useDefaultSpacing()
			.cssPaddingLeft('0rem')
			.cssPaddingTop('0rem')
			.cssPaddingBottom('0rem')

			.listen('click', () => {
				parentScene.stage.goBackTo(parentScene.depth);
				parentScene.linkSelection.selectedItems.value = [uuid];
			});
	}

	return component.listen('click', () => {
		if (
			(item.isDirectory == true &&
				configuration.allowedTypes.indexOf(Types.Directory) == -1) ||
			(item.isDirectory == false &&
				configuration.allowedTypes.indexOf(Types.File) == -1)
		) {
			currentPath.value = '';
			return;
		}

		currentPath.value = path;
	});
}

interface ItemTextCfg {
	name: string;
	isDirectory: boolean;
	parent: string;
	path: string;
	listUpdater: BindableObject<any>;
}

function ItemText(configuration: ItemTextCfg) {
	return [
		ItemOptionsMenu(configuration),
		Icon(configuration.isDirectory ? 'folder' : 'note'),
		Text(configuration.name)
			.cssFontFamily('mono-rg')
			.useDefaultPadding()
			.cssWidth('100%')
			.cssFlex(1),
	];
}

function ItemOptionsMenu(configuration: ItemTextCfg) {
	const { path, listUpdater, parent, isDirectory } = configuration;

	const isOpen = new State(false);
	const itemName = new State(configuration.name);

	async function deleteItem() {
		try {
			await rm(path);
		} catch {
			alert(`Failed to delete "${name}"`);
		}

		listUpdater.triggerAll();
	}
	async function renameItem() {
		try {
			const newName = itemName.value;
			const newPath = `${parent}/${newName}`;
			await rename(path, newPath);
		} catch {
			alert(`Failed to rename "${name}"`);
		}

		listUpdater.triggerAll();
	}

	return Popover({
		isOpen,
		accessibilityLabel: 'options',
		toggle: Button({
			style: ButtonStyles.Transparent,
			accessibilityLabel: 'show options',
			iconName: 'more_vert',
			action: () => (isOpen.value = !isOpen.value),
		}).cssColor('inherit'),
		content: VStack(
			Label(
				'Name',
				Input(new TextInputCfg(itemName, 'Untitled')).addToClass(
					'forcing-default-styles',
				),
			),

			Button({
				accessibilityLabel: 'rename item',
				iconName: 'edit',
				text: 'Rename',
				action: renameItem,
			}).addToClass('forcing-default-styles'),

			Separator(),

			Button({
				accessibilityLabel: 'open file',
				iconName: 'open_in_new',
				text: 'Open',
				action: () =>
					window.open(`${window.location.origin}/file/${path}`),
			})
				.hideConditionally(isDirectory)
				.addToClass('forcing-default-styles'),
			Separator().hideConditionally(isDirectory),

			Button({
				style: ButtonStyles.Destructive,
				accessibilityLabel: 'delete item',
				iconName: 'delete',
				text: 'Delete',
				action: deleteItem,
			}).addToClass('forcing-default-styles'),
		)
			.cssHeight('auto')
			.cssWidth('18rem')
			.useDefaultPadding()
			.useDefaultSpacing(),
	}).listen('keydown', (event) => event.stopPropagation());
}
